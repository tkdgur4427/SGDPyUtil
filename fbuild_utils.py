import os
import importlib
import shutil
import subprocess

from enum import Enum
from typing import List
from typing import Dict

from SGDPyUtil.winreg_utils import *
from SGDPyUtil.visual_studio_utils import *
from SGDPyUtil.logging_utils import Logger
from SGDPyUtil.singleton_utils import SingletonInstance
from SGDPyUtil.json_utils import *


class ModuleInfo:
    def __init__(self, module_name: str, module_path: str):
        self.name = module_name
        self.path = module_path
        return

    def import_as_py_module(self):
        # extract module folder
        module_folders = self.path.split("\\")
        # remove root folder and module py file
        module_folders = module_folders[1:]
        module_folders = module_folders[: len(module_folders) - 1]

        # construct module path
        import_lib = module_folders[0]
        for index in range(1, len(module_folders)):
            import_lib = import_lib + "." + module_folders[index]
        import_lib = import_lib + "." + self.name

        # import module
        importlib.import_module(import_lib)

        return


class FBModule:
    def __init__(self, module_name: str, module_path: str, is_executable=False):
        # module name
        self.name = module_name
        # module path
        self.src_path = module_path
        # module dir
        self.dir = os.path.dirname(self.src_path)
        # whether module is targetting library or executable
        self.is_executable = is_executable
        # dependent modules
        self.dependent_module_names: List[str] = []
        # additional include
        self.additional_include_paths: List[str] = []
        # additional src
        self.additional_src_paths: List[str] = []
        return

    def add_dependency(self, module_name: str):
        self.dependent_module_names.append(module_name)
        return

    def add_include_path(self, include_path: str):
        self.additional_include_paths.append(include_path)
        return

    def add_src_path(self, src_path: str):
        self.additional_src_paths.append(src_path)
        return


class BuildConf(Enum):
    DEBUG = 1
    PROFILE = 2
    RELEASE = 3


class FastBuild(SingletonInstance):
    def __init__(self):
        # get environments variables
        self.env_vars = os.environ

        # module infos to collect
        self.module_infos: Dict[str, ModuleInfo] = {}

        # modules to compile
        self.modules: Dict[str, FBModule] = {}

        # third_libraries
        self.third_library_include_paths: List[str] = []
        self.third_library_lib_paths: List[str] = []
        self.debug_library_names: List[str] = []
        self.release_library_names: List[str] = []

        # build configuration
        self.build_conf: BuildConf = None

        return

    def setup(self, output_path: str, intermediate_path: str):
        # set output_path and intermeidate_path
        self.output_path = output_path
        self.intermediate_path = intermediate_path

        # create directory
        if not os.path.isdir(self.output_path):
            os.mkdir(self.output_path)
        if not os.path.isdir(self.intermediate_path):
            os.mkdir(self.intermediate_path)

        # get bff_path
        bff_path = os.path.join(self.intermediate_path, "fbuild.bff")

        # generate bff file
        self.bff_file = open(bff_path, "w")

        # description for bff file
        self.add_text(
            ";*************************************************************************\n"
        )
        self.add_text(
            ";* Autogenerated bff - see FASTBuild.cs for how this file was generated. *\n"
        )
        self.add_text(
            ";*************************************************************************\n\n"
        )

        # set global variables
        self.add_text(f".OutputPath = '{self.output_path}'\n")
        self.add_text(f".IntermediatePath = '{self.intermediate_path}'\n\n")

        # cache sdk_root
        self.cache_sdk_root()

        # setup by environment variables
        self.write_env_setup()

        return

    def add_sym_link_to_output(self, src_path: str, dst_folder_name: str):
        """add symbolic link which is useful e.g. adding Data folder link to Output Folder which contains .exe file"""
        if self.build_conf != None:
            dst_dir = self.get_output_path(self.build_conf)
            dst_path = os.path.join(dst_dir, dst_folder_name)
            
            # re-create sym link
            if not os.path.isdir(dst_path):
                subprocess.check_call(f'mklink /J "{dst_path}" "{src_path}"', shell=True)

    def add_module(self, module: FBModule):
        self.modules[module.name] = module
        return

    def add_module_info(self, info: ModuleInfo):
        self.module_infos[info.name] = info
        return

    def collect_modules(self):
        for root, dirs, files in os.walk(".\\LSGD"):
            for file in files:
                if "Module.py" in file:
                    # get module name
                    module_name = file.split(".")[0]
                    # get module path
                    module_path = os.path.join(root, file)
                    # add module
                    self.add_module_info(ModuleInfo(module_name, module_path))
        return

    def import_modules(self):
        for name, info in self.module_infos.items():
            info.import_as_py_module()
        return

    def cache_sdk_root(self):
        sdk_root_dir_ref = [
            "",
        ]
        try_read_registry_key(
            "Microsoft\\Windows Kits\\Installed Roots", "KitsRoot10", sdk_root_dir_ref
        )

        if sdk_root_dir_ref[0] == "":
            try_read_registry_key(
                "Microsoft\\Microsoft SDKs\\Windows\\v10.0",
                "InstallationFolder",
                sdk_root_dir_ref,
            )

        # cache sdk_root_dir
        self.sdk_root_dir = sdk_root_dir_ref[0]

        return

    def get_base_include_paths(self, tool_chain_dir: str) -> List[str]:
        # include tool_chain_dir
        base_include_paths: List[str] = [
            os.path.join(tool_chain_dir, "include"),
        ]

        # cache sdk_version
        self.sdk_version = None

        # enumerate all windows sdks
        sdk_include_dir = os.path.join(self.sdk_root_dir, "include")

        version_dirs = []
        for version_dir in os.listdir(sdk_include_dir):
            version_path = os.path.join(sdk_include_dir, version_dir)
            sdk_version = version_dir
            if self.sdk_version != None and self.sdk_version > sdk_version:
                continue

            # cache sdk_version
            self.sdk_version = sdk_version

            # reset the directories
            version_dirs.clear()

            shared_dir = os.path.join(version_path, "shared")
            um_dir = os.path.join(version_path, "um")
            ucrt_dir = os.path.join(version_path, "ucrt")

            if os.path.exists(shared_dir):
                version_dirs.append(shared_dir)
            if os.path.exists(um_dir):
                version_dirs.append(um_dir)
            if os.path.exists(ucrt_dir):
                version_dirs.append(ucrt_dir)

        for version_dir in version_dirs:
            base_include_paths.append(version_dir)

        # add LSGD
        lsgd_path = os.path.abspath(os.path.join(".", "LSGD"))
        base_include_paths.append(lsgd_path)

        return base_include_paths

    def setup_third_libraries(self, third_library_path: str):
        # get src path
        src_path = os.path.join(third_library_path, "src")

        # list third libraries
        self.third_library_paths = []
        for dir in os.listdir(src_path):
            self.third_library_paths.append(os.path.join(src_path, dir))

        # extract include/lib paths
        self.third_library_include_paths: List[str] = []
        self.third_library_lib_paths: List[str] = []

        # extract .lib names
        self.debug_library_names = []
        self.release_library_names = []

        # search any deps.json
        deps_file_path = os.path.join(src_path, "deps.json")
        if os.path.exists(deps_file_path):
            deps = read_json_data(deps_file_path)

            deps_paths = deps.get("paths", None)
            if not deps_paths is None:
                for deps_path in deps_paths:
                    self.third_library_lib_paths.append(deps_path)

            deps_libs = deps.get("libs", None)
            if not deps_libs is None:
                for deps_lib in deps_libs:
                    self.debug_library_names.append(deps_lib)
                    self.release_library_names.append(deps_lib)

        for dir in self.third_library_paths:
            include_path = os.path.join(dir, "include")
            library_path = os.path.join(dir, "lib")

            # add include path
            if os.path.isdir(include_path):
                self.third_library_include_paths.append(include_path)

            # Debug library
            debug_library_path = os.path.join(library_path, "Debug")
            if os.path.isdir(debug_library_path):
                self.third_library_lib_paths.append(debug_library_path)

                for root, _, files in os.walk(debug_library_path):
                    for file in files:
                        ext = os.path.splitext(file)[1]
                        if ext == ".lib":
                            self.debug_library_names.append(file)

            # Release library
            release_library_path = os.path.join(library_path, "Release")
            if os.path.isdir(release_library_path):
                self.third_library_lib_paths.append(release_library_path)

                for root, _, files in os.walk(release_library_path):
                    for file in files:
                        ext = os.path.splitext(file)[1]
                        if ext == ".lib":
                            self.release_library_names.append(file)

        return

    def write_env_setup(self) -> bool:
        """
        #import
        """
        if "CommonProgramFiles" in self.env_vars:
            self.add_text("#import CommonProgramFiles\n")
        if "DXSDK_DIR" in self.env_vars:
            self.add_text("#import DXSDK_DIR\n")

        """
            Compiler 
        """

        # get the vs version
        vs_version = get_visual_studio_version()
        if vs_version == None:
            Logger.instance().info(f"[ERROR] visual studio is NOT valid")
            return False

        # get the vs install path
        vs_default_path = get_visual_studio_path(vs_version)
        vs_install_path = os.path.join(vs_default_path, "VC", "Tools", "MSVC")
        if not os.path.isdir(vs_install_path):
            Logger.instance().info(f"[ERROR] visual studio is NOT valid")
            return False

        # get valid tool chain
        tool_chain_dirs = []
        for dir in os.listdir(vs_install_path):
            compiler_exe = os.path.join(
                vs_install_path, dir, "bin", "Hostx64", "x64", "cl.exe"
            )
            if os.path.exists(compiler_exe):
                tool_chain_dirs.append(dir)

        if len(tool_chain_dirs) == 0:
            Logger.instance().info(f"[ERROR] no appropriate tool chain dir")
            return False

        # get the tool chain directory
        vs_version = tool_chain_dirs[0]
        tool_chain_dir = os.path.join(vs_install_path, vs_version)
        tool_chain_dir_bin = os.path.join(tool_chain_dir, "bin", "Hostx64", "x64")

        # compiler
        self.add_text("Compiler('LSGDCompiler')\n{\n")
        self.add_text(f"\t.Root = '{tool_chain_dir_bin}'\n")
        self.add_text(f"\t.Executable = '$Root$/cl.exe'\n")

        # start ExtraFiles
        self.add_text("\t.ExtraFiles =\n\t{\n")
        self.add_text("\t\t'$Root$/c1.dll'\n")
        self.add_text("\t\t'$Root$/c2.dll'\n")
        self.add_text("\t\t'$Root$/c1xx.dll'\n")
        self.add_text("\t\t'$Root$/1033/clui.dll'\n")
        self.add_text("\t\t'$Root$/mspdbsrv.exe'\n")
        self.add_text("\t\t'$Root$/mspdbcore.dll'\n")
        self.add_text("\t\t'$Root$/mspft140.dll'\n")
        self.add_text("\t\t'$Root$/msobj140.dll'\n")
        self.add_text("\t\t'$Root$/mspdb140.dll'\n")
        self.add_text("\t\t'$Root$/msvcp140.dll'\n")
        self.add_text("\t\t'$Root$/tbbmalloc.dll'\n")

        # get redist directory to find additional dll
        vs_redist_path = os.path.join(vs_default_path, "VC", "Redist", "MSVC")
        vs_redist_dirs = []
        for dir in os.listdir(vs_redist_path):
            redist_dir = os.path.join(vs_redist_path, dir)

            vccorlib140_dll = os.path.join(
                redist_dir, "x64", "Microsoft.VC142.CRT", "vccorlib140.dll"
            )
            if os.path.exists(vccorlib140_dll):
                vs_redist_dirs.append(redist_dir)

        if len(vs_redist_dirs) == 0:
            Logger.instance().info(f"[ERROR] no appropriate vs redist dir")
            return False

        vs_redist_dir = vs_redist_dirs[0]
        vs_redist_dir = os.path.join(vs_redist_dir, "x64", "Microsoft.VC142.CRT")

        # vcruntime140.dll
        vcruntime140_path = os.path.join(vs_redist_dir, "vcruntime140.dll")
        self.add_text(f"\t\t'{vcruntime140_path}'\n")

        # vccorlib140.dll
        vccorlib140_path = os.path.join(vs_redist_dir, "vccorlib140.dll")
        self.add_text(f"\t\t'{vccorlib140_path}'\n")

        # end ExtraFiles
        self.add_text("\t}\n")

        # CompilerFamily
        self.add_text("\t.CompilerFamily = 'msvc'\n")

        self.add_text("}\n")

        """
            Settings
        """
        self.add_text("Settings\n{\n")
        self.add_text("\t.Environment =\n\t{\n")

        # add PATH for vs settings
        IDE_path = os.path.join(vs_default_path, "VC", "Common7", "IDE")
        self.add_text(f'\t\t"PATH={IDE_path};{tool_chain_dir}",\n')

        # add TMP
        TMP_path = self.env_vars.get("TMP", None)
        if TMP_path != None:
            self.add_text(f'\t\t"TMP={TMP_path}"\n')

        # add SystemRoot
        system_root_path = self.env_vars.get("SystemRoot", None)
        if system_root_path != None:
            self.add_text(f'\t\t"SystemRoot={system_root_path}"\n')

        self.add_text("\t}\n")

        # use fbuild cache
        if TMP_path != None:
            fbuild_cache_path = os.path.join(TMP_path, ".build.cache")

            if not os.path.isdir(fbuild_cache_path):
                os.mkdir(fbuild_cache_path)

            self.add_text(f'\t.CachePath = "{fbuild_cache_path}"\n')

        self.add_text("}\n")

        """
            MSVC settings
        """
        """ .MSVC16_BaseConfig """
        # visual studio 2019
        self.add_text(".MSVC16_BaseConfig = [\n")
        # .AdditionalWarning
        self.add_text("\t.AdditionalWarnings = ''\n")
        # .CompilerOptions
        self.add_text("\t.CompilerOptions = ''\n")
        self.add_text("\t\t + ' \"%1\" /Z7'\n")  #
        self.add_text(
            "\t\t + ' /nologo'\n"
        )  # surpress the display of the copyright banner
        self.add_text("\t\t + ' /c'\n")  # compiles without linking
        self.add_text("\t\t + ' /W4'\n")  # warning level 4
        # self.add_text("\t\t + ' /Wall'\n")  # display all warning
        # self.add_text("\t\t + ' /WX'\n")                # treat warning as error
        # self.add_text("\t\t + ' /TP'\n")                # compile as C++
        self.add_text(
            "\t\t + ' /Zc:inline'\n"
        )  # remove unreferenced COMDATs at compile time (VS2013.2+)
        self.add_text(
            "\t\t + ' /Zc:strictStrings'\n"
        )  # require const only usage of string literals (VS2013+)
        self.add_text("\t\t + .AdditionalWarnings\n")  # see above
        self.add_text("\t\t + ' /fp:fast'\n")  # specifies floating-point behavior
        self.add_text("\t\t + ' /D\"WIN32_LEAN_AND_MEAN\" /D_WIN32 /D__WINDOWS__'\n")
        self.add_text(
            "\t\t + ' /D\"_CRT_SECURE_NO_WARNINGS\"'\n"
        )  # dont warn about unsafe functions
        self.add_text(
            "\t\t + ' /D\"_WINSOCK_DEPRECATED_NO_WARNINGS\"'\n"
        )  # dont warn about deprecated winsock functions
        # .PCHOptions
        self.add_text(
            "\t.PCHOptions = '' + .CompilerOptions + ' /Fp\"%2\" /Fo\"%3\"'\n"
        )
        self.add_text("\t.CompilerOptions + ' /Fo\"%2\"'\n")
        # .LibrarianOptions
        self.add_text("\t.LibrarianOptions = ''\n")
        self.add_text("\t\t + ' /NODEFAULTLIB'\n")  # ignores all default libraries
        self.add_text(
            "\t\t + ' /NOLOGO'\n"
        )  # supresses the display of the copyright banner
        self.add_text('\t\t + \' /OUT:"%2" "%1"\'\n')
        # .LinkerOptions
        self.add_text("\t.LinkerOptions = ''\n")
        self.add_text("\t\t + ' /NODEFAULTLIB'\n")  # ignores all default libraries
        self.add_text(
            "\t\t + ' /NOLOGO'\n"
        )  # supresses the display of the copyright banner
        self.add_text("\t\t + ' /INCREMENTAL:NO'\n")  # turn off incremental linking
        self.add_text('\t\t + \' /OUT:"%2" "%1"\'\n')
        self.add_text("\t\t + ' /DEBUG'\n")  # creates debugging information
        self.add_text(
            "\t\t + ' /IGNORE:4001'\n"
        )  # dont complain about linking libs only
        # .CompilerDebugOptimizations
        self.add_text("\t.CompilerDebugOptimizations = ''\n")
        self.add_text(
            "\t\t + ' /MTd'\n"
        )  # creates a debug multithreaded executable file using LIBCMTD.lib
        self.add_text("\t\t + ' /Od'\n")  # disables optimizations
        self.add_text("\t\t + ' /RTC1'\n")  # enables run-time error checks
        self.add_text("\t\t + ' /GS'\n")  # buffers security check
        self.add_text("\t\t + ' /Oy-'\n")  # disable omitting frame pointer (x86 only)
        self.add_text("\t\t + ' /Oi'\n")  # generates intrinsic functions
        self.add_text("\t\t + ' /GR-'\n")  # disables run-time type information (RTTI)
        self.add_text("\t\t + ' /EHa-'\n")  # disables exceptions
        # .CompilerReleaseOptimizations
        self.add_text("\t.CompilerReleaseOptimizations = ''\n")
        self.add_text(
            "\t\t + ' /MT'\n"
        )  # creates a multithreaded executable file using LIBCMT.lib
        self.add_text("\t\t + ' /Ox'\n")  # uses maximum optimization
        self.add_text("\t\t + ' /Oy'\n")  # omits frame pointer (x86 only)
        self.add_text("\t\t + ' /Oi'\n")  # generates intrinsic functions
        self.add_text("\t\t + ' /GS-'\n")  # disables buffers security check
        self.add_text("\t\t + ' /GF'\n")  # enables string pooling
        self.add_text("\t\t + ' /GL'\n")  # enables while program optimization
        self.add_text("\t\t + ' /Gy'\n")  # enables function-level linking
        self.add_text(
            "\t\t + ' /Gw'\n"
        )  # enables whole-program global data optimization
        self.add_text("\t\t + ' /GR-'\n")  # disables run-time type information (RTTI)
        self.add_text("\t\t + ' /EHa-'\n")  # disables exceptions
        # .LibrarianDebugOptimizations
        self.add_text("\t.LibrarianDebugOptimizations = ''\n")
        # .LibrarianReleaseOptimizations
        self.add_text(
            "\t.LibrarianReleaseOptimizations = ' /LTCG'\n"
        )  # specifies link-time code generation
        # .LinkerDebugOptimizations
        self.add_text("\t.LinkerDebugOptimizations = ''\n")
        # .LinkerReleaseOptimizations
        self.add_text(
            "\t.LinkerReleaseOptimizations = ' /LTCG'\n"
        )  # specifies link-time code generation
        self.add_text("\t\t + ' /OPT:REF,ICF'\n")

        # .BaseIncludePaths
        self.add_text("\t.BaseIncludePaths = ' /I\".\"'\n")
        include_paths = self.get_base_include_paths(tool_chain_dir)
        for include_path in include_paths:
            self.add_text(f"\t\t + ' /I\"{include_path}\"'\n")

        # add third library include path
        for third_library_include_path in self.third_library_include_paths:
            self.add_text(f"\t\t + ' /I\"{third_library_include_path}\"'\n")

        # .CompilerOptions
        self.add_text("\t.CompilerOptions + .BaseIncludePaths\n")
        # .PCHOptions
        self.add_text("\t.PCHOptions + .BaseIncludePaths\n")

        # .WindowsLibPath
        sdk_lib_dir = os.path.join(
            self.sdk_root_dir,
            "Lib",
            self.sdk_version,  # drived by self.get_base_include_paths()
        )
        self.add_text(f"\t.WindowsLibPath = '{sdk_lib_dir}'\n")
        self.add_text("]\n")

        """ .MSVC16x64_BaseConfig """
        # x64 base config
        self.add_text(".MSVC16x64_BaseConfig = [\n")
        self.add_text("\tUsing(.MSVC16_BaseConfig)\n")
        self.add_text(f"\t.ToolsBasePath = '{tool_chain_dir_bin}'\n")
        self.add_text("\t.PlatformInfo = 'Windows'\n")
        self.add_text("\t.ArchInfo = 'x64'\n")
        self.add_text("\t.CompilerInfo = 'MSVC16'\n")
        self.add_text("\t.Compiler = 'LSGDCompiler'\n")
        self.add_text("\t.Librarian = '$ToolsBasePath$\lib.exe'\n")
        self.add_text("\t.Linker = '$ToolsBasePath$\link.exe'\n")
        self.add_text("\t.CompilerOptions + ' /DWIN64'\n")
        self.add_text("\t.PCHOptions + ' /DWIN64'\n")
        self.add_text("\t.LinkerOptions + ' /MACHINE:X64'\n")
        self.add_text("\t\t + ' /LIBPATH:\"$WindowsLibPath$\\ucrt\\x64\"'\n")
        self.add_text("\t\t + ' /LIBPATH:\"$WindowsLibPath$\\um\\x64\"'\n")

        # add tool_chain_dir_lib
        tool_chain_dir_lib = os.path.join(tool_chain_dir, "lib", "x64")
        self.add_text(f"\t\t + ' /LIBPATH:\"{tool_chain_dir_lib}\"'\n")

        # add third library lib paths
        for third_library_lib_path in self.third_library_lib_paths:
            self.add_text(f"\t\t + ' /LIBPATH:\"{third_library_lib_path}\"'\n")

        self.add_text("]\n")

        """ .MSVC16x64_DebugConfig """
        # x64 debug config
        self.add_text(".MSVC16x64_DebugConfig = [\n")
        self.add_text("\tUsing(.MSVC16x64_BaseConfig)\n")
        self.add_text("\t.Config = 'Debug'\n")
        self.add_text("\t.CompilerOptions + ' /DDEBUG /D_DEBUG /DPROFILING_ENABLED'\n")
        self.add_text("\t\t + .CompilerDebugOptimizations\n")
        self.add_text("\t.PCHOptions + ' /DDEBUG /D_DEBUG /DPROFILING_ENABLED'\n")
        self.add_text("\t\t + .CompilerDebugOptimizations\n")
        self.add_text("\t.LibrarianOptions + .LibrarianDebugOptimizations\n")
        self.add_text("\t.LinkerOptions + .LinkerDebugOptimizations\n")
        self.add_text(
            "\t\t + ' libcmtd.lib libucrtd.lib libvcruntimed.lib kernel32.lib'\n"
        )

        # join third_library's library name
        debug_lib_list = " ".join(self.debug_library_names)
        self.add_text(f"\t\t + ' {debug_lib_list}'\n")

        self.add_text("]\n")

        """ .MSVC16x64_ReleaseConfig """
        # x64 release config
        self.add_text(".MSVC16x64_ReleaseConfig = [\n")
        self.add_text("\tUsing(.MSVC16x64_BaseConfig)\n")
        self.add_text("\t.Config = 'Release'\n")
        self.add_text("\t.CompilerOptions + '/DRELEASE'\n")
        self.add_text("\t.PCHOptions + '/DRELEASE'\n\n")
        self.add_text(
            "\t// setup de-optimization options (FASTBUILD_DEOPTIMIZE_OBJECT)\n"
        )
        self.add_text("\t.DeoptimizeWritableFilesWithToken = true\n")
        self.add_text("\t.CompilerOptionsDeoptimized = '$CompilerOptions$ /Od'\n")
        self.add_text("\t.PCHOptionsDeoptimized = '$PCHOptions$ /Od'\n\n")
        self.add_text("\t.CompilerOptions + .CompilerReleaseOptimizations\n")
        self.add_text("\t.LibrarianOptions + .LibrarianReleaseOptimizations\n")
        self.add_text("\t.LinkerOptions + .LinkerReleaseOptimizations\n")
        self.add_text(
            "\t\t + ' libcmt.lib libucrt.lib libvcruntime.lib kernel32.lib'\n"
        )

        # join third_library's library name
        release_lib_list = " ".join(self.release_library_names)
        self.add_text(f"\t\t + ' {release_lib_list}'\n")

        self.add_text("]\n")

        """ .MSVC16x64_ProfileConfig """
        # x64 profile config
        self.add_text(".MSVC16x64_ProfileConfig = [\n")
        self.add_text("\tUsing(.MSVC16x64_ReleaseConfig)\n")
        self.add_text("\t.Config = 'Profile'\n")
        self.add_text("\t.CompilerOptions + ' /DPROFILING_ENABLED'\n")
        self.add_text("\t.PCHOptions + ' /DPROFILING_ENABLED'\n")
        self.add_text("\t.DeoptimizeWritableFilesWithToken = false\n")
        self.add_text("]\n\n")

        """ .Configs_Windows_MSVC16 """
        self.add_text(".Configs_Windows_MSVC16 = {\n")
        self.add_text("\t.MSVC16x64_DebugConfig\n")
        self.add_text("\t,.MSVC16x64_ProfileConfig\n")
        self.add_text("\t,.MSVC16x64_ReleaseConfig\n")
        self.add_text("}\n\n")

        return True

    def add_lib_module_bff(self, module: FBModule):
        self.add_text("{\n")
        self.add_text(f"\t.ProjectName = '{module.name}'\n")
        self.add_text(f"\t.ProjectPath = '{module.dir}'\n")
        self.add_text("\t{\n")
        self.add_text("\t\t.UnityInputPath = {\n")

        # add default src path
        self.add_text(f"\t\t\t'{module.src_path}'\n")

        # add additional src paths
        for src_path in module.additional_src_paths:
            self.add_text(f"\t\t\t'{src_path}',\n")

        self.add_text("\t\t}\n")

        self.add_text("\t\t.UnityInputPattern = {'*.cpp', '*.c'}\n")
        self.add_text(
            "\t\t.UnityOutputPath = '$IntermediatePath$\\Unity\\$ProjectName$\\'\n"
        )
        self.add_text("\t\tUnity('$ProjectName$-Unity'){}\n")
        self.add_text("\t}\n\n")
        self.add_text("\tForEach(.Config in .Configs_Windows_MSVC16) {\n")
        self.add_text("\t\tUsing(.Config)\n")
        self.add_text(
            "\t\t.OutputPath + '\\$PlatformInfo$-$ArchInfo$-$CompilerInfo$-$Config$\\'\n"
        )
        self.add_text(
            "\t\t.IntermediatePath + '\\$PlatformInfo$-$ArchInfo$-$CompilerInfo$-$Config$\\'\n"
        )

        # additonal includes
        if len(module.additional_include_paths) > 0:
            self.add_text("\t\t.CompilerOptions \n")
            for include_path in module.additional_include_paths:
                self.add_text(f"\t\t + ' /I\"{include_path}\"'\n")

        """ Library() """
        self.add_text(
            "\t\tLibrary('$ProjectName$-Lib-$PlatformInfo$-$ArchInfo$-$CompilerInfo$-$Config$') {\n"
        )

        # .PreBuildDependencies
        self.add_text("\t\t\t.PreBuildDependencies = {\n")

        for module_name in module.dependent_module_names:
            self.add_text(
                f"\t\t\t\t'{module_name}-$PlatformInfo$-$ArchInfo$-$CompilerInfo$-$Config$'\n"
            )

        self.add_text("\t\t\t}\n")
        self.add_text("\t\t\t.CompilerInputUnity = '$ProjectName$-Unity'\n")
        self.add_text(
            "\t\t\t.CompilerOutputPath = '$IntermediatePath$\\$ProjectName$-Build\\'\n"
        )
        self.add_text("\t\t\t.LibrarianOutput = '$OutputPath$\\$ProjectName$.lib'\n")
        self.add_text("\t\t}\n")

        """ Alias() """
        self.add_text(
            "\t\tAlias('$ProjectName$-$PlatformInfo$-$ArchInfo$-$CompilerInfo$-$Config$') {\n"
        )
        self.add_text(
            "\t\t\t.Targets = '$ProjectName$-Lib-$PlatformInfo$-$ArchInfo$-$CompilerInfo$-$Config$'\n"
        )
        self.add_text("\t\t}\n")

        self.add_text("\t}\n")
        self.add_text("}\n\n")

        return

    def add_exe_module_bff(self, module: FBModule):
        self.add_text("{\n")
        self.add_text(f"\t.ProjectName = '{module.name}'\n")
        self.add_text(f"\t.ProjectPath = '{module.dir}'\n")
        self.add_text("\t{\n")
        self.add_text("\t\t.UnityInputPath = {\n")

        # add default src path
        self.add_text(f"\t\t\t'{module.src_path}'\n")

        # add additional src paths
        for src_path in module.additional_src_paths:
            self.add_text(f"\t\t\t'{src_path}',\n")

        self.add_text("\t\t}\n")
        self.add_text("\t\t.UnityInputPattern = {'*.cpp'}\n")
        self.add_text(
            "\t\t.UnityOutputPath = '$IntermediatePath$\\Unity\\$ProjectName$\\'\n"
        )
        self.add_text("\t\tUnity('$ProjectName$-Unity'){}\n")
        self.add_text("\t}\n\n")
        self.add_text("\tForEach(.Config in .Configs_Windows_MSVC16) {\n")
        self.add_text("\t\tUsing(.Config)\n")
        self.add_text("\t\t.CompilerOptions + ''\n")
        self.add_text("\t\t\t + ' /wd4710' // function not inlined \n")

        # add additional include folder for dependent modules
        for module_name in module.dependent_module_names:
            dependent_module = self.modules[module_name]
            for include_path in dependent_module.additional_include_paths:
                self.add_text(f"\t\t\t + ' /I\"{include_path}\"' \n")

        self.add_text(
            "\t\t.OutputPath + '\\$PlatformInfo$-$ArchInfo$-$CompilerInfo$-$Config$\\'\n"
        )
        self.add_text(
            "\t\t.IntermediatePath + '\\$PlatformInfo$-$ArchInfo$-$CompilerInfo$-$Config$\\'\n"
        )

        """ ObjectList """
        self.add_text(
            "\t\tObjectList('$ProjectName$-Lib-$PlatformInfo$-$ArchInfo$-$CompilerInfo$-$Config$') {\n"
        )
        self.add_text("\t\t\t.CompilerInputUnity = '$ProjectName$-Unity'\n")
        self.add_text(
            "\t\t\t.CompilerOutputPath = '$IntermediatePath$\\$ProjectName$-Build\\'\n"
        )
        self.add_text("\t\t}\n")

        """ Executable """
        self.add_text(
            "\t\tExecutable('$ProjectName$-Exe-$PlatformInfo$-$ArchInfo$-$CompilerInfo$-$Config$') {\n"
        )

        # .PreBuildDependencies
        self.add_text("\t\t\t.PreBuildDependencies = {\n")

        for module_name in module.dependent_module_names:
            self.add_text(
                f"\t\t\t\t'{module_name}-$PlatformInfo$-$ArchInfo$-$CompilerInfo$-$Config$'\n"
            )

        self.add_text("\t\t\t}\n")
        # .Librarian
        self.add_text("\t\t\t.Libraries = {\n")
        self.add_text(
            "\t\t\t\t'$ProjectName$-Lib-$PlatformInfo$-$ArchInfo$-$CompilerInfo$-$Config$'\n"
        )

        for module_name in module.dependent_module_names:
            self.add_text(
                f"\t\t\t\t'{module_name}-$PlatformInfo$-$ArchInfo$-$CompilerInfo$-$Config$'\n"
            )

        self.add_text("\t\t\t}\n")

        self.add_text("\t\t\t.LinkerOutput = '$OutputPath$\\$ProjectName$.exe'\n")
        self.add_text("\t\t\t.LinkerOptions + ' /SUBSYSTEM:CONSOLE'\n")

        """ override linker options """
        # add .lib path ($OutputPath$)
        self.add_text(f"\t\t\t\t + ' /LIBPATH:\"$OutputPath$\"'\n")

        # add .lib file in $OutputPath$ for all dependent modules
        library_names: List[str] = []
        for module_name in module.dependent_module_names:
            library_names.append(f"{module_name}.lib")
        library_names = " ".join(library_names)

        if len(library_names) > 0:
            self.add_text(f"\t\t\t\t + ' {library_names}'\n")

        self.add_text("\t\t}\n")

        """ Alias """
        self.add_text(
            "\t\tAlias('$ProjectName$-$PlatformInfo$-$ArchInfo$-$CompilerInfo$-$Config$') {\n"
        )
        self.add_text(
            "\t\t\t.Targets = '$ProjectName$-Exe-$PlatformInfo$-$ArchInfo$-$CompilerInfo$-$Config$'\n"
        )
        self.add_text("\t\t}\n")

        self.add_text("\t}\n")
        self.add_text("}\n\n")

        return

    def finalize_alias(self, build_conf: BuildConf):
        """ForEach All Alias"""
        self.add_text("ForEach(.Config in .Configs_Windows_MSVC16) {\n")
        self.add_text("\tUsing(.Config)\n")
        self.add_text(
            "\tAlias('All-$PlatformInfo$-$ArchInfo$-$CompilerInfo$-$Config$') {\n"
        )
        self.add_text("\t\t.Targets = {\n")

        module_contents = []
        for name, module in self.modules.items():
            module_contents.append(
                f"\t\t\t'{name}-$PlatformInfo$-$ArchInfo$-$CompilerInfo$-$Config$'"
            )
        self.add_text(",\n".join(module_contents))
        self.add_text("\n")

        self.add_text("\t\t}\n")
        self.add_text("\t}\n")
        self.add_text("}\n")

        # by default, BuildConf.DEBUG
        build_configuration = "\t\t'All-Windows-x64-MSVC16-Debug'\n"
        if build_conf == BuildConf.PROFILE:
            build_configuration = "\t\t'All-Windows-x64-MSVC16-Profile'\n"
        elif build_conf == BuildConf.RELEASE:
            build_configuration = "\t\t'All-Windows-x64-MSVC16-Release'\n"

        """ All Alias"""
        self.add_text("Alias('All') {\n")
        self.add_text("\t.Targets = {\n")
        self.add_text(build_configuration)
        self.add_text("\t}\n")
        self.add_text("}\n")

        return

    def construct_build_graph(self) -> List[str]:
        # find executable and construct list of module name
        module_names: List[str] = []
        executable_modules: List[str] = []
        for name, module in self.modules.items():
            if module.is_executable == True:
                executable_modules.append(name)
            else:
                module_names.append(name)

        if len(executable_modules) > 1:
            Logger.instance().info(f"[ERROR] more than one executable module!")
            raise RuntimeError()

        # calculate dependency costs
        module_dep_costs: Dict[str, int] = {}
        for module_name in module_names:
            module = self.modules.get(module_name, None)

            # calculate dep costs
            # @todo - need to calculate recursive dep costs
            cost = len(module.dependent_module_names)

            module_dep_costs[module_name] = cost

        # sort by dep costs
        ordered_modules_by_dep_cost = dict(
            sorted(module_dep_costs.items(), key=lambda item: item[1])
        )

        # construct build graph
        build_graph: List[str] = []
        for name, _ in ordered_modules_by_dep_cost.items():
            build_graph.append(name)

        # append last executable module
        build_graph.append(executable_modules[0])

        return build_graph

    def generate_bff_file(self, build_conf: BuildConf):
        # cache build conf.
        self.build_conf = build_conf

        # get build graph
        build_graph = self.construct_build_graph()

        # looping module generate
        for module_name in build_graph:
            module = self.modules[module_name]
            if not module.is_executable:
                self.add_lib_module_bff(module)
            if module.is_executable:
                self.add_exe_module_bff(module)

        # Alias('All')
        self.finalize_alias(build_conf)

        # dump the bff file (fbuild.bff)
        self.dump()
        return

    def get_output_path(self, build_conf: BuildConf):
        output_path_postfix = "Debug"
        if build_conf is BuildConf.PROFILE:
            output_path_postfix = "Profile"
        elif build_conf is BuildConf.RELEASE:
            output_path_postfix = "Release"

        output_path = os.path.join(
            self.output_path, f"Windows-x64-MSVC16-{output_path_postfix}"
        )
        return output_path

    def add_text(self, text: str):
        self.bff_file.write(text)
        return

    def dump(self):
        self.bff_file.close()
        return

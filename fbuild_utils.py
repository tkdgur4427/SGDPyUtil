import os
import winreg
import importlib

from enum import Enum
from typing import List
from typing import Dict

from SGDPyUtil.logging_utils import Logger
from SGDPyUtil.singleton_utils import SingletonInstance


class ModuleInfo:
    def __init__(self, module_name: str, module_path: str):
        self.name = module_name
        self.path = module_path
        return

    def import_as_py_module(self):
        # extract module folder
        module_folders = self.path.split("\\")
        # remove root folder and module py file
        module_folders = module_folders[1:]
        module_folders = module_folders[: len(module_folders) - 1]

        # construct module path
        import_lib = module_folders[0]
        for index in range(1, len(module_folders)):
            import_lib = import_lib + "." + module_folders[index]
        import_lib = import_lib + "." + self.name

        # import module
        importlib.import_module(import_lib)

        return


class FBModule:
    def __init__(self, module_name: str, module_path: str, is_executable=False):
        # module name
        self.name = module_name
        # module path
        self.path = module_path
        # module dir
        self.dir = os.path.dirname(self.path)
        # whether module is targetting library or executable
        self.is_executable = is_executable
        # dependent modules
        self.dependent_module_names: List[str] = []
        return

    def add_dependency(self, module_name: str):
        self.dependent_module_names.append(module_name)
        return


class BuildConf(Enum):
    DEBUG = 1
    PROFILE = 2
    RELEASE = 3


class FastBuild(SingletonInstance):
    def __init__(self):
        # get environments variables
        self.env_vars = os.environ

        # module infos to collect
        self.module_infos: Dict[str, ModuleInfo] = {}

        # modules to compile
        self.modules: Dict[str, FBModule] = {}

        return

    def setup(self, output_path: str, intermediate_path: str):
        # set output_path and intermeidate_path
        self.output_path = output_path
        self.intermediate_path = intermediate_path

        # create directory
        if not os.path.isdir(self.output_path):
            os.mkdir(self.output_path)
        if not os.path.isdir(self.intermediate_path):
            os.mkdir(self.intermediate_path)

        # get bff_path
        bff_path = os.path.join(self.intermediate_path, "fbuild.bff")

        # generate bff file
        self.bff_file = open(bff_path, "w")

        # description for bff file
        self.add_text(
            ";*************************************************************************\n"
        )
        self.add_text(
            ";* Autogenerated bff - see FASTBuild.cs for how this file was generated. *\n"
        )
        self.add_text(
            ";*************************************************************************\n\n"
        )

        # set global variables
        self.add_text(f".OutputPath = '{self.output_path}'\n")
        self.add_text(f".IntermediatePath = '{self.intermediate_path}'\n\n")

        # setup registry keys
        self.setup_registry_keys()

        # cache sdk_root
        self.cache_sdk_root()

        # setup by environment variables
        self.write_env_setup()

        return

    def add_module(self, module: FBModule):
        self.modules[module.name] = module
        return

    def add_module_info(self, info: ModuleInfo):
        self.module_infos[info.name] = info
        return

    def collect_modules(self):
        for root, dirs, files in os.walk(".\\LSGD"):
            for file in files:
                if "Module.py" in file:
                    # get module name
                    module_name = file.split(".")[0]
                    # get module path
                    module_path = os.path.join(root, file)
                    # add module
                    self.add_module_info(ModuleInfo(module_name, module_path))
        return

    def import_modules(self):
        for name, info in self.module_infos.items():
            info.import_as_py_module()
        return

    def setup_registry_keys(self):
        self.registry_keys = []
        self.registry_keys.append((winreg.HKEY_CURRENT_USER, "SOFTWARE\%s"))
        self.registry_keys.append((winreg.HKEY_LOCAL_MACHINE, "SOFTWARE\%s"))
        self.registry_keys.append((winreg.HKEY_CURRENT_USER, "SOFTWARE\WOW6432Node\%s"))
        self.registry_keys.append(
            (winreg.HKEY_LOCAL_MACHINE, "SOFTWARE\WOW6432Node\%s")
        )
        return

    def try_read_registry_key(
        self, sub_key: str, value_name: str = None, value=None
    ) -> bool:
        is_matched_key_found = False
        for registry_key in self.registry_keys:
            key = registry_key[0]
            sub_key_root = registry_key[1]
            try:
                combined_sub_key = sub_key_root % sub_key
                opened_key = winreg.OpenKey(key, combined_sub_key)
                if value_name != None and len(value) == 1:
                    value[0] = winreg.QueryValueEx(opened_key, value_name)[0]
                # key is found
                is_matched_key_found = True
            except:
                pass
        return is_matched_key_found

    def get_visual_studio_version(self) -> str:
        common_key_path = "\Microsoft\VisualStudio\%s"
        possible_vs_versions = [
            "16.0",  # visual studio 2019
        ]
        installed_vs_versions = []
        for version in possible_vs_versions:
            key_suffix = common_key_path % version
            if self.try_read_registry_key(key_suffix):
                installed_vs_versions.append(version)

        return installed_vs_versions[0] if len(installed_vs_versions) else None

    def cache_sdk_root(self):
        sdk_root_dir_ref = [
            "",
        ]
        self.try_read_registry_key(
            "Microsoft\\Windows Kits\\Installed Roots", "KitsRoot10", sdk_root_dir_ref
        )

        if sdk_root_dir_ref[0] == "":
            self.try_read_registry_key(
                "Microsoft\\Microsoft SDKs\\Windows\\v10.0",
                "InstallationFolder",
                sdk_root_dir_ref,
            )

        # cache sdk_root_dir
        self.sdk_root_dir = sdk_root_dir_ref[0]

        return

    def get_base_include_paths(self, tool_chain_dir: str) -> List[str]:
        # include tool_chain_dir
        base_include_paths: List[str] = [
            os.path.join(tool_chain_dir, "include"),
        ]

        # cache sdk_version
        self.sdk_version = None

        # enumerate all windows sdks
        sdk_include_dir = os.path.join(self.sdk_root_dir, "include")

        version_dirs = []
        for version_dir in os.listdir(sdk_include_dir):
            version_path = os.path.join(sdk_include_dir, version_dir)
            sdk_version = version_dir
            if self.sdk_version != None and self.sdk_version > sdk_version:
                continue

            # cache sdk_version
            self.sdk_version = sdk_version

            # reset the directories
            version_dirs.clear()

            shared_dir = os.path.join(version_path, "shared")
            um_dir = os.path.join(version_path, "um")
            ucrt_dir = os.path.join(version_path, "ucrt")

            if os.path.exists(shared_dir):
                version_dirs.append(shared_dir)
            if os.path.exists(um_dir):
                version_dirs.append(um_dir)
            if os.path.exists(ucrt_dir):
                version_dirs.append(ucrt_dir)

        for version_dir in version_dirs:
            base_include_paths.append(version_dir)

        # add LSGD
        lsgd_path = os.path.abspath(os.path.join(".", "LSGD"))
        base_include_paths.append(lsgd_path)

        return base_include_paths

    def write_env_setup(self) -> bool:
        """
        #import
        """
        if "CommonProgramFiles" in self.env_vars:
            self.add_text("#import CommonProgramFiles\n")
        if "DXSDK_DIR" in self.env_vars:
            self.add_text("#import DXSDK_DIR\n")

        """
            Compiler 
        """

        # write fbuild's Compiler syntax
        vs_ver_mapper = {
            "16.0": "2019",
        }

        # get the vs version
        vs_version = self.get_visual_studio_version()
        if vs_version == None:
            Logger.instance().info(f"[ERROR] visual studio is NOT valid")
            return False

        # get the vs install path
        vs_version = vs_ver_mapper.get(vs_version, None)
        vs_default_path = (
            f"C:\Program Files (x86)\Microsoft Visual Studio\{vs_version}\Professional"
        )
        vs_install_path = os.path.join(vs_default_path, "VC", "Tools", "MSVC")
        if not os.path.isdir(vs_install_path):
            Logger.instance().info(f"[ERROR] visual studio is NOT valid")
            return False

        # get valid tool chain
        tool_chain_dirs = []
        for dir in os.listdir(vs_install_path):
            compiler_exe = os.path.join(
                vs_install_path, dir, "bin", "Hostx64", "x64", "cl.exe"
            )
            if os.path.exists(compiler_exe):
                tool_chain_dirs.append(dir)

        if len(tool_chain_dirs) == 0:
            Logger.instance().info(f"[ERROR] no appropriate tool chain dir")
            return False

        # get the tool chain directory
        vs_version = tool_chain_dirs[0]
        tool_chain_dir = os.path.join(vs_install_path, vs_version)
        tool_chain_dir_bin = os.path.join(tool_chain_dir, "bin", "Hostx64", "x64")

        # compiler
        self.add_text("Compiler('LSGDCompiler')\n{\n")
        self.add_text(f"\t.Root = '{tool_chain_dir_bin}'\n")
        self.add_text(f"\t.Executable = '$Root$/cl.exe'\n")

        # start ExtraFiles
        self.add_text("\t.ExtraFiles =\n\t{\n")
        self.add_text("\t\t'$Root$/c1.dll'\n")
        self.add_text("\t\t'$Root$/c2.dll'\n")
        self.add_text("\t\t'$Root$/c1xx.dll'\n")
        self.add_text("\t\t'$Root$/1033/clui.dll'\n")
        self.add_text("\t\t'$Root$/mspdbsrv.exe'\n")
        self.add_text("\t\t'$Root$/mspdbcore.dll'\n")
        self.add_text("\t\t'$Root$/mspft140.dll'\n")
        self.add_text("\t\t'$Root$/msobj140.dll'\n")
        self.add_text("\t\t'$Root$/mspdb140.dll'\n")
        self.add_text("\t\t'$Root$/msvcp140.dll'\n")
        self.add_text("\t\t'$Root$/tbbmalloc.dll'\n")

        # get redist directory to find additional dll
        vs_redist_path = os.path.join(vs_default_path, "VC", "Redist", "MSVC")
        vs_redist_dirs = []
        for dir in os.listdir(vs_redist_path):
            redist_dir = os.path.join(vs_redist_path, dir)

            vccorlib140_dll = os.path.join(
                redist_dir, "x64", "Microsoft.VC142.CRT", "vccorlib140.dll"
            )
            if os.path.exists(vccorlib140_dll):
                vs_redist_dirs.append(redist_dir)

        if len(vs_redist_dirs) == 0:
            Logger.instance().info(f"[ERROR] no appropriate vs redist dir")
            return False

        vs_redist_dir = vs_redist_dirs[0]
        vs_redist_dir = os.path.join(vs_redist_dir, "x64", "Microsoft.VC142.CRT")

        # vcruntime140.dll
        vcruntime140_path = os.path.join(vs_redist_dir, "vcruntime140.dll")
        self.add_text(f"\t\t'{vcruntime140_path}'\n")

        # vccorlib140.dll
        vccorlib140_path = os.path.join(vs_redist_dir, "vccorlib140.dll")
        self.add_text(f"\t\t'{vccorlib140_path}'\n")

        # end ExtraFiles
        self.add_text("\t}\n")

        # CompilerFamily
        self.add_text("\t.CompilerFamily = 'msvc'\n")

        self.add_text("}\n")

        """
            Settings
        """
        self.add_text("Settings\n{\n")
        self.add_text("\t.Environment =\n\t{\n")

        # add PATH for vs settings
        IDE_path = os.path.join(vs_default_path, "VC", "Common7", "IDE")
        self.add_text(f'\t\t"PATH={IDE_path};{tool_chain_dir}",\n')

        # add TMP
        TMP_path = self.env_vars.get("TMP", None)
        if TMP_path != None:
            self.add_text(f'\t\t"TMP={TMP_path}"\n')

        # add SystemRoot
        system_root_path = self.env_vars.get("SystemRoot", None)
        if system_root_path != None:
            self.add_text(f'\t\t"SystemRoot={system_root_path}"\n')

        self.add_text("\t}\n")

        # use fbuild cache
        if TMP_path != None:
            fbuild_cache_path = os.path.join(TMP_path, ".build.cache")

            if not os.path.isdir(fbuild_cache_path):
                os.mkdir(fbuild_cache_path)

            self.add_text(f'\t.CachePath = "{fbuild_cache_path}"\n')

        self.add_text("}\n")

        """
            MSVC settings
        """
        """ .MSVC16_BaseConfig """
        # visual studio 2019
        self.add_text(".MSVC16_BaseConfig = [\n")
        # .AdditionalWarning
        self.add_text("\t.AdditionalWarnings = ''\n")
        # .CompilerOptions
        self.add_text("\t.CompilerOptions = ''\n")
        self.add_text("\t\t + ' \"%1\" /Z7'\n")  #
        self.add_text(
            "\t\t + ' /nologo'\n"
        )  # surpress the display of the copyright banner
        self.add_text("\t\t + ' /c'\n")  # compiles without linking
        self.add_text("\t\t + ' /W4'\n")  # warning level 4
        # self.add_text("\t\t + ' /Wall'\n")  # display all warning
        # self.add_text("\t\t + ' /WX'\n")                # treat warning as error
        # self.add_text("\t\t + ' /TP'\n")                # compile as C++
        self.add_text(
            "\t\t + ' /Zc:inline'\n"
        )  # remove unreferenced COMDATs at compile time (VS2013.2+)
        self.add_text(
            "\t\t + ' /Zc:strictStrings'\n"
        )  # require const only usage of string literals (VS2013+)
        self.add_text("\t\t + .AdditionalWarnings\n")  # see above
        self.add_text("\t\t + ' /fp:fast'\n")  # specifies floating-point behavior
        self.add_text("\t\t + ' /D\"WIN32_LEAN_AND_MEAN\" /D_WIN32 /D__WINDOWS__'\n")
        self.add_text(
            "\t\t + ' /D\"_CRT_SECURE_NO_WARNINGS\"'\n"
        )  # dont warn about unsafe functions
        self.add_text(
            "\t\t + ' /D\"_WINSOCK_DEPRECATED_NO_WARNINGS\"'\n"
        )  # dont warn about deprecated winsock functions
        # .PCHOptions
        self.add_text(
            "\t.PCHOptions = '' + .CompilerOptions + ' /Fp\"%2\" /Fo\"%3\"'\n"
        )
        self.add_text("\t.CompilerOptions + ' /Fo\"%2\"'\n")
        # .LibrarianOptions
        self.add_text("\t.LibrarianOptions = ''\n")
        self.add_text("\t\t + ' /NODEFAULTLIB'\n")  # ignores all default libraries
        self.add_text(
            "\t\t + ' /NOLOGO'\n"
        )  # supresses the display of the copyright banner
        self.add_text('\t\t + \' /OUT:"%2" "%1"\'\n')
        # .LinkerOptions
        self.add_text("\t.LinkerOptions = ''\n")
        self.add_text("\t\t + ' /NODEFAULTLIB'\n")  # ignores all default libraries
        self.add_text(
            "\t\t + ' /NOLOGO'\n"
        )  # supresses the display of the copyright banner
        self.add_text("\t\t + ' /INCREMENTAL:NO'\n")  # turn off incremental linking
        self.add_text('\t\t + \' /OUT:"%2" "%1"\'\n')
        self.add_text("\t\t + ' /DEBUG'\n")  # creates debugging information
        self.add_text(
            "\t\t + ' /IGNORE:4001'\n"
        )  # dont complain about linking libs only
        # .CompilerDebugOptimizations
        self.add_text("\t.CompilerDebugOptimizations = ''\n")
        self.add_text(
            "\t\t + ' /MTd'\n"
        )  # creates a debug multithreaded executable file using LIBCMTD.lib
        self.add_text("\t\t + ' /Od'\n")  # disables optimizations
        self.add_text("\t\t + ' /RTC1'\n")  # enables run-time error checks
        self.add_text("\t\t + ' /GS'\n")  # buffers security check
        self.add_text("\t\t + ' /Oy-'\n")  # disable omitting frame pointer (x86 only)
        self.add_text("\t\t + ' /Oi'\n")  # generates intrinsic functions
        self.add_text("\t\t + ' /GR-'\n")  # disables run-time type information (RTTI)
        self.add_text("\t\t + ' /EHa-'\n")  # disables exceptions
        # .CompilerReleaseOptimizations
        self.add_text("\t.CompilerReleaseOptimizations = ''\n")
        self.add_text(
            "\t\t + ' /MT'\n"
        )  # creates a multithreaded executable file using LIBCMT.lib
        self.add_text("\t\t + ' /Ox'\n")  # uses maximum optimization
        self.add_text("\t\t + ' /Oy'\n")  # omits frame pointer (x86 only)
        self.add_text("\t\t + ' /Oi'\n")  # generates intrinsic functions
        self.add_text("\t\t + ' /GS-'\n")  # disables buffers security check
        self.add_text("\t\t + ' /GF'\n")  # enables string pooling
        self.add_text("\t\t + ' /GL'\n")  # enables while program optimization
        self.add_text("\t\t + ' /Gy'\n")  # enables function-level linking
        self.add_text(
            "\t\t + ' /Gw'\n"
        )  # enables whole-program global data optimization
        self.add_text("\t\t + ' /GR-'\n")  # disables run-time type information (RTTI)
        self.add_text("\t\t + ' /EHa-'\n")  # disables exceptions
        # .LibrarianDebugOptimizations
        self.add_text("\t.LibrarianDebugOptimizations = ''\n")
        # .LibrarianReleaseOptimizations
        self.add_text(
            "\t.LibrarianReleaseOptimizations = ' /LTCG'\n"
        )  # specifies link-time code generation
        # .LinkerDebugOptimizations
        self.add_text("\t.LinkerDebugOptimizations = ''\n")
        # .LinkerReleaseOptimizations
        self.add_text(
            "\t.LinkerReleaseOptimizations = ' /LTCG'\n"
        )  # specifies link-time code generation
        self.add_text("\t\t + ' /OPT:REF,ICF'\n")

        # .BaseIncludePaths
        self.add_text("\t.BaseIncludePaths = ' /I\".\"'\n")
        include_paths = self.get_base_include_paths(tool_chain_dir)
        for include_path in include_paths:
            self.add_text(f"\t\t + ' /I\"{include_path}\"'\n")

        # .CompilerOptions
        self.add_text("\t.CompilerOptions + .BaseIncludePaths\n")
        # .PCHOptions
        self.add_text("\t.PCHOptions + .BaseIncludePaths\n")

        # .WindowsLibPath
        sdk_lib_dir = os.path.join(
            self.sdk_root_dir,
            "Lib",
            self.sdk_version,  # drived by self.get_base_include_paths()
        )
        self.add_text(f"\t.WindowsLibPath = '{sdk_lib_dir}'\n")
        self.add_text("]\n")

        """ .MSVC16x64_BaseConfig """
        # x64 base config
        self.add_text(".MSVC16x64_BaseConfig = [\n")
        self.add_text("\tUsing(.MSVC16_BaseConfig)\n")
        self.add_text(f"\t.ToolsBasePath = '{tool_chain_dir_bin}'\n")
        self.add_text("\t.PlatformInfo = 'Windows'\n")
        self.add_text("\t.ArchInfo = 'x64'\n")
        self.add_text("\t.CompilerInfo = 'MSVC16'\n")
        self.add_text("\t.Compiler = 'LSGDCompiler'\n")
        self.add_text("\t.Librarian = '$ToolsBasePath$\lib.exe'\n")
        self.add_text("\t.Linker = '$ToolsBasePath$\link.exe'\n")
        self.add_text("\t.CompilerOptions + ' /DWIN64'\n")
        self.add_text("\t.PCHOptions + ' /DWIN64'\n")
        self.add_text("\t.LinkerOptions + ' /MACHINE:X64'\n")
        self.add_text("\t\t + ' /LIBPATH:\"$WindowsLibPath$\\ucrt\\x64\"'\n")
        self.add_text("\t\t + ' /LIBPATH:\"$WindowsLibPath$\\um\\x64\"'\n")

        # add tool_chain_dir_lib
        tool_chain_dir_lib = os.path.join(tool_chain_dir, "lib", "x64")
        self.add_text(f"\t\t + ' /LIBPATH:\"{tool_chain_dir_lib}\"'\n")

        self.add_text("]\n")

        """ .MSVC16x64_DebugConfig """
        # x64 debug config
        self.add_text(".MSVC16x64_DebugConfig = [\n")
        self.add_text("\tUsing(.MSVC16x64_BaseConfig)\n")
        self.add_text("\t.Config = 'Debug'\n")
        self.add_text("\t.CompilerOptions + ' /DDEBUG /D_DEBUG /DPROFILING_ENABLED'\n")
        self.add_text("\t\t + .CompilerDebugOptimizations\n")
        self.add_text("\t.PCHOptions + ' /DDEBUG /D_DEBUG /DPROFILING_ENABLED'\n")
        self.add_text("\t\t + .CompilerDebugOptimizations\n")
        self.add_text("\t.LibrarianOptions + .LibrarianDebugOptimizations\n")
        self.add_text("\t.LinkerOptions + .LinkerDebugOptimizations\n")
        self.add_text(
            "\t\t + ' libcmtd.lib libucrtd.lib libvcruntimed.lib kernel32.lib'\n"
        )
        self.add_text("]\n")

        """ .MSVC16x64_ReleaseConfig """
        # x64 release config
        self.add_text(".MSVC16x64_ReleaseConfig = [\n")
        self.add_text("\tUsing(.MSVC16x64_BaseConfig)\n")
        self.add_text("\t.Config = 'Release'\n")
        self.add_text("\t.CompilerOptions + '/DRELEASE'\n")
        self.add_text("\t.PCHOptions + '/DRELEASE'\n\n")
        self.add_text(
            "\t// setup de-optimization options (FASTBUILD_DEOPTIMIZE_OBJECT)\n"
        )
        self.add_text("\t.DeoptimizeWritableFilesWithToken = true\n")
        self.add_text("\t.CompilerOptionsDeoptimized = '$CompilerOptions$ /Od'\n")
        self.add_text("\t.PCHOptionsDeoptimized = '$PCHOptions$ /Od'\n\n")
        self.add_text("\t.CompilerOptions + .CompilerReleaseOptimizations\n")
        self.add_text("\t.LibrarianOptions + .LibrarianReleaseOptimizations\n")
        self.add_text("\t.LinkerOptions + .LinkerReleaseOptimizations\n")
        self.add_text(
            "\t\t + ' libcmt.lib libucrt.lib libvcruntime.lib kernel32.lib'\n"
        )
        self.add_text("]\n")

        """ .MSVC16x64_ProfileConfig """
        # x64 profile config
        self.add_text(".MSVC16x64_ProfileConfig = [\n")
        self.add_text("\tUsing(.MSVC16x64_ReleaseConfig)\n")
        self.add_text("\t.Config = 'Profile'\n")
        self.add_text("\t.CompilerOptions + ' /DPROFILING_ENABLED'\n")
        self.add_text("\t.PCHOptions + ' /DPROFILING_ENABLED'\n")
        self.add_text("\t.DeoptimizeWritableFilesWithToken = false\n")
        self.add_text("]\n\n")

        """ .Configs_Windows_MSVC16 """
        self.add_text(".Configs_Windows_MSVC16 = {\n")
        self.add_text("\t.MSVC16x64_DebugConfig\n")
        self.add_text("\t,.MSVC16x64_ProfileConfig\n")
        self.add_text("\t,.MSVC16x64_ReleaseConfig\n")
        self.add_text("}\n\n")

        return True

    def add_lib_module_bff(self, module: FBModule):
        self.add_text("{\n")
        self.add_text(f"\t.ProjectName = '{module.name}'\n")
        self.add_text(f"\t.ProjectPath = '{module.dir}'\n")
        self.add_text("\t{\n")
        self.add_text("\t\t.UnityInputPath = '$ProjectPath$\\src'\n")
        self.add_text("\t\t.UnityInputPattern = {'*.cpp'}\n")
        self.add_text(
            "\t\t.UnityOutputPath = '$IntermediatePath$\\Unity\\$ProjectName$\\'\n"
        )
        self.add_text("\t\tUnity('$ProjectName$-Unity'){}\n")
        self.add_text("\t}\n\n")
        self.add_text("\tForEach(.Config in .Configs_Windows_MSVC16) {\n")
        self.add_text("\t\tUsing(.Config)\n")
        self.add_text(
            "\t\t.OutputPath + '\\$PlatformInfo$-$ArchInfo$-$CompilerInfo$-$Config$\\'\n"
        )
        self.add_text(
            "\t\t.IntermediatePath + '\\$PlatformInfo$-$ArchInfo$-$CompilerInfo$-$Config$\\'\n"
        )

        """ Library() """
        self.add_text(
            "\t\tLibrary('$ProjectName$-Lib-$PlatformInfo$-$ArchInfo$-$CompilerInfo$-$Config$') {\n"
        )

        # .PreBuildDependencies
        self.add_text("\t\t\t.PreBuildDependencies = {\n")

        for module_name in module.dependent_module_names:
            self.add_text(
                f"\t\t\t\t'{module_name}-$PlatformInfo$-$ArchInfo$-$CompilerInfo$-$Config$'\n"
            )

        self.add_text("\t\t\t}\n")
        self.add_text("\t\t\t.CompilerInputUnity = '$ProjectName$-Unity'\n")
        self.add_text(
            "\t\t\t.CompilerOutputPath = '$IntermediatePath$\\$ProjectName$-Build\\'\n"
        )
        self.add_text("\t\t\t.LibrarianOutput = '$OutputPath$\\$ProjectName$.lib'\n")
        self.add_text("\t\t}\n")

        """ Alias() """
        self.add_text(
            "\t\tAlias('$ProjectName$-$PlatformInfo$-$ArchInfo$-$CompilerInfo$-$Config$') {\n"
        )
        self.add_text(
            "\t\t\t.Targets = '$ProjectName$-Lib-$PlatformInfo$-$ArchInfo$-$CompilerInfo$-$Config$'\n"
        )
        self.add_text("\t\t}\n")

        self.add_text("\t}\n")
        self.add_text("}\n\n")

        return

    def add_exe_module_bff(self, module: FBModule):
        self.add_text("{\n")
        self.add_text(f"\t.ProjectName = '{module.name}'\n")
        self.add_text(f"\t.ProjectPath = '{module.dir}'\n")
        self.add_text("\t{\n")
        self.add_text("\t\t.UnityInputPath = '$ProjectPath$\\src'\n")
        self.add_text("\t\t.UnityInputPattern = {'*.cpp'}\n")
        self.add_text(
            "\t\t.UnityOutputPath = '$IntermediatePath$\\Unity\\$ProjectName$\\'\n"
        )
        self.add_text("\t\tUnity('$ProjectName$-Unity'){}\n")
        self.add_text("\t}\n\n")
        self.add_text("\tForEach(.Config in .Configs_Windows_MSVC16) {\n")
        self.add_text("\t\tUsing(.Config)\n")
        self.add_text("\t\t.CompilerOptions + ''\n")
        self.add_text("\t\t\t + ' /wd4710' // function not inlined \n")
        self.add_text(
            "\t\t.OutputPath + '\\$PlatformInfo$-$ArchInfo$-$CompilerInfo$-$Config$\\'\n"
        )
        self.add_text(
            "\t\t.IntermediatePath + '\\$PlatformInfo$-$ArchInfo$-$CompilerInfo$-$Config$\\'\n"
        )

        """ ObjectList """
        self.add_text(
            "\t\tObjectList('$ProjectName$-Lib-$PlatformInfo$-$ArchInfo$-$CompilerInfo$-$Config$') {\n"
        )
        self.add_text("\t\t\t.CompilerInputUnity = '$ProjectName$-Unity'\n")
        self.add_text(
            "\t\t\t.CompilerOutputPath = '$IntermediatePath$\\$ProjectName$-Build\\'\n"
        )
        self.add_text("\t\t}\n")

        """ Executable """
        self.add_text(
            "\t\tExecutable('$ProjectName$-Exe-$PlatformInfo$-$ArchInfo$-$CompilerInfo$-$Config$') {\n"
        )

        # .PreBuildDependencies
        self.add_text("\t\t\t.PreBuildDependencies = {\n")

        for module_name in module.dependent_module_names:
            self.add_text(
                f"\t\t\t\t'{module_name}-$PlatformInfo$-$ArchInfo$-$CompilerInfo$-$Config$'\n"
            )

        self.add_text("\t\t\t}\n")
        # .Librarian
        self.add_text("\t\t\t.Libraries = {\n")
        self.add_text(
            "\t\t\t\t'$ProjectName$-Lib-$PlatformInfo$-$ArchInfo$-$CompilerInfo$-$Config$'\n"
        )

        for module_name in module.dependent_module_names:
            self.add_text(
                f"\t\t\t\t'{module_name}-$PlatformInfo$-$ArchInfo$-$CompilerInfo$-$Config$'\n"
            )

        self.add_text("\t\t\t}\n")

        self.add_text("\t\t\t.LinkerOutput = '$OutputPath$\\$ProjectName$.exe'\n")
        self.add_text("\t\t\t.LinkerOptions + ' /SUBSYSTEM:CONSOLE'\n")

        self.add_text("\t\t}\n")

        """ Alias """
        self.add_text(
            "\t\tAlias('$ProjectName$-$PlatformInfo$-$ArchInfo$-$CompilerInfo$-$Config$') {\n"
        )
        self.add_text(
            "\t\t\t.Targets = '$ProjectName$-Exe-$PlatformInfo$-$ArchInfo$-$CompilerInfo$-$Config$'\n"
        )
        self.add_text("\t\t}\n")

        self.add_text("\t}\n")
        self.add_text("}\n\n")

        return

    def finalize_alias(self, build_conf: BuildConf):
        """ForEach All Alias"""
        self.add_text("ForEach(.Config in .Configs_Windows_MSVC16) {\n")
        self.add_text("\tUsing(.Config)\n")
        self.add_text(
            "\tAlias('All-$PlatformInfo$-$ArchInfo$-$CompilerInfo$-$Config$') {\n"
        )
        self.add_text("\t\t.Targets = {\n")

        module_contents = []
        for name, module in self.modules.items():
            module_contents.append(
                f"\t\t\t'{name}-$PlatformInfo$-$ArchInfo$-$CompilerInfo$-$Config$'"
            )
        self.add_text(",\n".join(module_contents))
        self.add_text("\n")

        self.add_text("\t\t}\n")
        self.add_text("\t}\n")
        self.add_text("}\n")

        # by default, BuildConf.DEBUG
        build_configuration = "\t\t'All-Windows-x64-MSVC16-Debug'\n"
        if build_conf == BuildConf.PROFILE:
            build_configuration = "\t\t'All-Windows-x64-MSVC16-Profile'\n"
        elif build_conf == BuildConf.RELEASE:
            build_configuration = "\t\t'All-Windows-x64-MSVC16-Release'\n"

        """ All Alias"""
        self.add_text("Alias('All') {\n")
        self.add_text("\t.Targets = {\n")
        self.add_text(build_configuration)
        self.add_text("\t}\n")
        self.add_text("}\n")

        return

    def generate_bff_file(self, build_conf: BuildConf):
        # looping module generate
        for name, module in self.modules.items():
            if not module.is_executable:
                self.add_lib_module_bff(module)
            if module.is_executable:
                self.add_exe_module_bff(module)

        # Alias('All')
        self.finalize_alias(build_conf)

        # dump the bff file (fbuild.bff)
        self.dump()
        return

    def get_output_path(self, build_conf: BuildConf):
        output_path_postfix = "Debug"
        if build_conf is BuildConf.PROFILE:
            output_path_postfix = "Profile"
        elif build_conf is BuildConf.RELEASE:
            output_path_postfix = "Release"

        output_path = os.path.join(
            self.output_path, f"Windows-x64-MSVC16-{output_path_postfix}"
        )
        return output_path

    def add_text(self, text: str):
        self.bff_file.write(text)
        return

    def dump(self):
        self.bff_file.close()
        return
